"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1721],{1721:function(e,a,n){n.r(a),n(7378);var t=n(2682),r=["components"];function l(){return l=Object.assign?Object.assign.bind():function(e){for(var a=1;a<arguments.length;a++){var n=arguments[a];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e},l.apply(this,arguments)}function o(e){var a=e.components,n=function(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},l=Object.keys(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(t=0;t<l.length;t++)n=l[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}(e,r);return(0,t.kt)("wrapper",l({components:a},n),(0,t.kt)("p",null,"resolver 是一个帮助寻找模块绝对路径的库。\n一个模块可以作为另一个模块的依赖模块，然后被后者引用，如下："),(0,t.kt)("pre",null,(0,t.kt)("code",{className:"hljs language-js",parentName:"pre"},(0,t.kt)("span",{className:"token keyword",parentName:"code"},"import")," foo ",(0,t.kt)("span",{className:"token keyword",parentName:"code"},"from")," ",(0,t.kt)("span",{className:"token string",parentName:"code"},"'path/to/module'"),(0,t.kt)("span",{className:"token punctuation",parentName:"code"},";"),"\n",(0,t.kt)("span",{className:"token comment",parentName:"code"},"// 或者"),"\n",(0,t.kt)("span",{className:"token function",parentName:"code"},"require"),(0,t.kt)("span",{className:"token punctuation",parentName:"code"},"("),(0,t.kt)("span",{className:"token string",parentName:"code"},"'path/to/module'"),(0,t.kt)("span",{className:"token punctuation",parentName:"code"},")"),(0,t.kt)("span",{className:"token punctuation",parentName:"code"},";"))),(0,t.kt)("p",null,"所依赖的模块可以是来自应用程序的代码或第三方库。\nresolver 帮助 webpack 从每个 ",(0,t.kt)("inlineCode",{parentName:"p"},"require"),"/",(0,t.kt)("inlineCode",{parentName:"p"},"import")," 语句中，找到需要引入到 bundle 中的模块代码。\n当打包模块时，webpack 使用 ",(0,t.kt)("a",{href:"https://github.com/webpack/enhanced-resolve",parentName:"p"},"enhanced-resolve")," 来解析文件路径。"),(0,t.kt)("h2",null,(0,t.kt)("span",{id:"resolving-rules-in-webpack",parentName:"h2"}),"webpack 中的解析规则",(0,t.kt)("a",{href:"#resolving-rules-in-webpack","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,t.kt)("span",{className:"header-link",parentName:"a"}))),(0,t.kt)("p",null,"使用 ",(0,t.kt)("inlineCode",{parentName:"p"},"enhanced-resolve"),"，webpack 能解析三种文件路径："),(0,t.kt)("h3",null,(0,t.kt)("span",{id:"absolute-paths",parentName:"h3"}),"绝对路径",(0,t.kt)("a",{href:"#absolute-paths","aria-hidden":"true",tabIndex:"-1",parentName:"h3"},(0,t.kt)("span",{className:"header-link",parentName:"a"}))),(0,t.kt)("pre",null,(0,t.kt)("code",{className:"hljs language-js",parentName:"pre"},(0,t.kt)("span",{className:"token keyword",parentName:"code"},"import")," ",(0,t.kt)("span",{className:"token string",parentName:"code"},"'/home/me/file'"),(0,t.kt)("span",{className:"token punctuation",parentName:"code"},";"),"\n\n",(0,t.kt)("span",{className:"token keyword",parentName:"code"},"import")," ",(0,t.kt)("span",{className:"token string",parentName:"code"},"'C:\\\\Users\\\\me\\\\file'"),(0,t.kt)("span",{className:"token punctuation",parentName:"code"},";"))),(0,t.kt)("p",null,"由于已经获得文件的绝对路径，因此不需要再做进一步解析。"),(0,t.kt)("h3",null,(0,t.kt)("span",{id:"relative-paths",parentName:"h3"}),"相对路径",(0,t.kt)("a",{href:"#relative-paths","aria-hidden":"true",tabIndex:"-1",parentName:"h3"},(0,t.kt)("span",{className:"header-link",parentName:"a"}))),(0,t.kt)("pre",null,(0,t.kt)("code",{className:"hljs language-js",parentName:"pre"},(0,t.kt)("span",{className:"token keyword",parentName:"code"},"import")," ",(0,t.kt)("span",{className:"token string",parentName:"code"},"'../src/file1'"),(0,t.kt)("span",{className:"token punctuation",parentName:"code"},";"),"\n",(0,t.kt)("span",{className:"token keyword",parentName:"code"},"import")," ",(0,t.kt)("span",{className:"token string",parentName:"code"},"'./file2'"),(0,t.kt)("span",{className:"token punctuation",parentName:"code"},";"))),(0,t.kt)("p",null,"在这种情况下，使用 ",(0,t.kt)("inlineCode",{parentName:"p"},"import")," 或 ",(0,t.kt)("inlineCode",{parentName:"p"},"require")," 的资源文件所处的目录，被认为是上下文目录。在 ",(0,t.kt)("inlineCode",{parentName:"p"},"import/require")," 中给定的相对路径，会拼接此上下文路径，来生成模块的绝对路径。"),(0,t.kt)("h3",null,(0,t.kt)("span",{id:"module-paths",parentName:"h3"}),"模块路径",(0,t.kt)("a",{href:"#module-paths","aria-hidden":"true",tabIndex:"-1",parentName:"h3"},(0,t.kt)("span",{className:"header-link",parentName:"a"}))),(0,t.kt)("pre",null,(0,t.kt)("code",{className:"hljs language-js",parentName:"pre"},(0,t.kt)("span",{className:"token keyword",parentName:"code"},"import")," ",(0,t.kt)("span",{className:"token string",parentName:"code"},"'module'"),(0,t.kt)("span",{className:"token punctuation",parentName:"code"},";"),"\n",(0,t.kt)("span",{className:"token keyword",parentName:"code"},"import")," ",(0,t.kt)("span",{className:"token string",parentName:"code"},"'module/lib/file'"),(0,t.kt)("span",{className:"token punctuation",parentName:"code"},";"))),(0,t.kt)("p",null,"在 ",(0,t.kt)("a",{href:"/configuration/resolve/#resolvemodules",parentName:"p"},(0,t.kt)("inlineCode",{parentName:"a"},"resolve.modules"))," 中指定的所有目录中检索模块。\n你可以通过配置别名的方式来替换初始模块路径，具体请参照 ",(0,t.kt)("a",{href:"/configuration/resolve/#resolvealias",parentName:"p"},(0,t.kt)("inlineCode",{parentName:"a"},"resolve.alias"))," 配置选项。"),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"如果 package 中包含 ",(0,t.kt)("inlineCode",{parentName:"li"},"package.json")," 文件，那么在 ",(0,t.kt)("a",{href:"/configuration/resolve/#resolveexportsfields",parentName:"li"},(0,t.kt)("inlineCode",{parentName:"a"},"resolve.exportsFields"))," 配置选项中指定的字段会被依次查找，",(0,t.kt)("inlineCode",{parentName:"li"},"package.json")," 中的第一个字段会根据 ",(0,t.kt)("a",{href:"/guides/package-exports/",parentName:"li"},"package 导出指南"),"确定 package 中可用的 export。")),(0,t.kt)("p",null,"一旦根据上述规则解析路径后，resolver 将会检查路径是指向文件还是文件夹。如果路径指向文件："),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"如果文件具有扩展名，则直接将文件打包。"),(0,t.kt)("li",{parentName:"ul"},"否则，将使用 ",(0,t.kt)("a",{href:"/configuration/resolve/#resolveextensions",parentName:"li"},(0,t.kt)("inlineCode",{parentName:"a"},"resolve.extensions"))," 选项作为文件扩展名来解析，此选项会告诉解析器在解析中能够接受那些扩展名（例如 ",(0,t.kt)("inlineCode",{parentName:"li"},".js"),"，",(0,t.kt)("inlineCode",{parentName:"li"},".jsx"),"）。")),(0,t.kt)("p",null,"如果路径指向一个文件夹，则进行如下步骤寻找具有正确扩展名的文件："),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"如果文件夹中包含 ",(0,t.kt)("inlineCode",{parentName:"li"},"package.json")," 文件，则会根据 ",(0,t.kt)("a",{href:"/configuration/resolve/#resolvemainfields",parentName:"li"},(0,t.kt)("inlineCode",{parentName:"a"},"resolve.mainFields"))," 配置中的字段顺序查找，并根据 ",(0,t.kt)("inlineCode",{parentName:"li"},"package.json")," 中的符合配置要求的第一个字段来确定文件路径。"),(0,t.kt)("li",{parentName:"ul"},"如果不存在 ",(0,t.kt)("inlineCode",{parentName:"li"},"package.json")," 文件或 ",(0,t.kt)("a",{href:"/configuration/resolve/#resolvemainfields",parentName:"li"},(0,t.kt)("inlineCode",{parentName:"a"},"resolve.mainFields"))," 没有返回有效路径，则会根据 ",(0,t.kt)("a",{href:"/configuration/resolve/#resolvemainfiles",parentName:"li"},(0,t.kt)("inlineCode",{parentName:"a"},"resolve.mainFiles"))," 配置选项中指定的文件名顺序查找，看是否能在 import/require 的目录下匹配到一个存在的文件名。"),(0,t.kt)("li",{parentName:"ul"},"然后使用 ",(0,t.kt)("a",{href:"/configuration/resolve/#resolveextensions",parentName:"li"},(0,t.kt)("inlineCode",{parentName:"a"},"resolve.extensions"))," 选项，以类似的方式解析文件扩展名。")),(0,t.kt)("p",null,"Webpack 会根据构建目标，为这些选项提供合理的",(0,t.kt)("a",{href:"/configuration/resolve",parentName:"p"},"默认"),"配置。"),(0,t.kt)("h2",null,(0,t.kt)("span",{id:"resolving-loaders",parentName:"h2"}),"解析 loader",(0,t.kt)("a",{href:"#resolving-loaders","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,t.kt)("span",{className:"header-link",parentName:"a"}))),(0,t.kt)("p",null,"loader 的解析规则也遵循特定的规范。但是 ",(0,t.kt)("a",{href:"/configuration/resolve/#resolveloader",parentName:"p"},(0,t.kt)("inlineCode",{parentName:"a"},"resolveLoader"))," 配置项可以为 loader 设置独立的解析规则。"),(0,t.kt)("h2",null,(0,t.kt)("span",{id:"caching",parentName:"h2"}),"缓存",(0,t.kt)("a",{href:"#caching","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,t.kt)("span",{className:"header-link",parentName:"a"}))),(0,t.kt)("p",null,"每次文件系统访问文件都会被缓存，以便于更快触发对同一文件的多个并行或串行请求。在 ",(0,t.kt)("a",{href:"/configuration/watch/#watch",parentName:"p"},"watch 模式")," 下，只有修改过的文件会被从缓存中移出。如果关闭 watch 模式，则会在每次编译前清理缓存。"),(0,t.kt)("p",null,"欲了解更多上述配置信息，请查阅 ",(0,t.kt)("a",{href:"/configuration/resolve",parentName:"p"},"Resolve API"),"。"))}o.isMDXComponent=!0,a.default=o}}]);